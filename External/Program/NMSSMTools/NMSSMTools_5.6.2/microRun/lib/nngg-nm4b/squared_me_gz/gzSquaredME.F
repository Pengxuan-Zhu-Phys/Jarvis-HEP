*#define CHECK

#if 0
* gzSquaredME.F
* assembly of squared matrix element
* generated by FormCalc 8.0 on 6-Apr-2015 0:18
#endif

#include "gzvars.h"

************************************************************************

	RealType function gzsumup(CCloop, CCtree)
	implicit none

#include "gzvars.h"

	ComplexType CCloop(1), CCtree(1)
	ComplexType m

	gzsumup = 0

	m = 0
	m = m + CCloop(1)*1
	gzsumup = gzsumup + Re(Conjugate(CCtree(1))*m)
	end

************************************************************************

	subroutine gzSquaredMEHel(result, flags)
	implicit none
	RealType result(*)
	integer flags

#include "gzvars.h"

	RealType gzsumup
	external gzsumup

	flags=3

* gzBEGIN ABBR_HEL
	TEST(flags, BIT_LOOP)
	call gzabbr1h1
	call gzabbr1h2
	call gzabbr1h3
	call gzabbr1h4
	call gzabbr1h5
	call gzabbr1h6
	ENDTEST(flags, BIT_LOOP)
* gzEND ABBR_HEL

* gzBEGIN FF_INI
	Cloop(1) = 0
* gzEND FF_INI

	TEST(flags, BIT_LOOP)
* gzBEGIN FF_LOOP
	call gzvert

	LOOP(cha5, 1,2,1)
	call gzbox_cha5
	ENDLOOP(cha5)

	LOOP(his5, 1,3,1)
	call gzvert_his5
	ENDLOOP(his5)

	LOOP(lpd5, 1,3,1)
	call gzvert_lpd5
	call gzbox_lpd5
	ENDLOOP(lpd5)

	LOOP(neu5, 1,5,1)
	call gzvert_neu5
	ENDLOOP(neu5)

	LOOP(qud5, 1,3,1)
	call gzvert_qud5
	call gzbox_qud5
	ENDLOOP(qud5)

	LOOP(quu5, 1,3,1)
	call gzvert_quu5
	call gzbox_quu5
	ENDLOOP(quu5)

	LOOP(sld5, 1,3,1)
	call gzvert_sld5
	ENDLOOP(sld5)

	LOOP(sle5, 1,3,1)
	call gzvert_sle5
	ENDLOOP(sle5)

	LOOP(sqd5, 1,3,1)
	call gzvert_sqd5
	ENDLOOP(sqd5)

	LOOP(sqe5, 1,3,1)
	call gzvert_sqe5
	ENDLOOP(sqe5)

	LOOP(squ5, 1,3,1)
	call gzvert_squ5
	ENDLOOP(squ5)

	LOOP(sqv5, 1,3,1)
	call gzvert_sqv5
	ENDLOOP(sqv5)

	LOOP(cha6, 1,2,1)
	LOOP(cha5, 1,2,1)
	call gzvert_cha5_cha6
	call gzbox_cha5_cha6
	ENDLOOP(cha5)
	ENDLOOP(cha6)

	LOOP(neu5, 1,5,1)
	LOOP(cha5, 1,2,1)
	call gzvert_cha5_neu5
	ENDLOOP(cha5)
	ENDLOOP(neu5)

	LOOP(lpd5, 1,3,1)
	LOOP(hia5, 1,2,1)
	call gzvert_hia5_lpd5
	ENDLOOP(hia5)
	ENDLOOP(lpd5)

	LOOP(qud5, 1,3,1)
	LOOP(hia5, 1,2,1)
	call gzvert_hia5_qud5
	ENDLOOP(hia5)
	ENDLOOP(qud5)

	LOOP(quu5, 1,3,1)
	LOOP(hia5, 1,2,1)
	call gzvert_hia5_quu5
	ENDLOOP(hia5)
	ENDLOOP(quu5)

	LOOP(lpd5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_lpd5
	ENDLOOP(his5)
	ENDLOOP(lpd5)

	LOOP(qud5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_qud5
	ENDLOOP(his5)
	ENDLOOP(qud5)

	LOOP(quu5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_quu5
	ENDLOOP(his5)
	ENDLOOP(quu5)

	LOOP(sld5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_sld5
	ENDLOOP(his5)
	ENDLOOP(sld5)

	LOOP(sle5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_sle5
	ENDLOOP(his5)
	ENDLOOP(sle5)

	LOOP(sqd5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_sqd5
	ENDLOOP(his5)
	ENDLOOP(sqd5)

	LOOP(sqe5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_sqe5
	ENDLOOP(his5)
	ENDLOOP(sqe5)

	LOOP(squ5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_squ5
	ENDLOOP(his5)
	ENDLOOP(squ5)

	LOOP(sqv5, 1,3,1)
	LOOP(his5, 1,3,1)
	call gzvert_his5_sqv5
	ENDLOOP(his5)
	ENDLOOP(sqv5)

	LOOP(neu5, 1,5,1)
	LOOP(lpd5, 1,3,1)
	call gzvert_lpd5_neu5
	ENDLOOP(lpd5)
	ENDLOOP(neu5)

	LOOP(qud5, 1,3,1)
	LOOP(neu5, 1,5,1)
	call gzvert_neu5_qud5
	ENDLOOP(neu5)
	ENDLOOP(qud5)

	LOOP(quu5, 1,3,1)
	LOOP(neu5, 1,5,1)
	call gzvert_neu5_quu5
	ENDLOOP(neu5)
	ENDLOOP(quu5)

	LOOP(hia5, 1,2,1)
	LOOP(cha6, 1,2,1)
	LOOP(cha5, 1,2,1)
	call gzvert_cha5_cha6_hia5
	ENDLOOP(cha5)
	ENDLOOP(cha6)
	ENDLOOP(hia5)

	LOOP(his5, 1,3,1)
	LOOP(cha6, 1,2,1)
	LOOP(cha5, 1,2,1)
	call gzvert_cha5_cha6_his5
	ENDLOOP(cha5)
	ENDLOOP(cha6)
	ENDLOOP(his5)

	result(2) = result(2) + gzsumup(Cloop, Cloop)
* gzEND FF_LOOP
	ENDTEST(flags, BIT_LOOP)
	end

************************************************************************

	subroutine gzSquaredME(result, helicities, flags)
	implicit none
	RealType result(*)
	integer helicities
	integer flags

#include "gzvars.h"

* gzBEGIN VARDECL
	external gzSquaredMEHel

	integer Hel1, Hel2, Hel3, Hel4
	equivalence (Hel(1), Hel1)
	equivalence (Hel(2), Hel2)
	equivalence (Hel(3), Hel3)
	equivalence (Hel(4), Hel4)

* gzEND VARDECL

#include "inline.h"

       flags=3
	PREP(bhel,ehel, vec,vec_end, b0a,e0a, b0s,e0s)

* gzBEGIN INVARIANTS
	S = SInvariant(k(1),k(2))
	T = TInvariant(k(1),k(3))
	U = TInvariant(k(2),k(3))
* gzEND INVARIANTS

	TEST(flags, BIT_RESET)
* gzBEGIN ABBR_S
	seq(1) = seq(1) + 1
	INI_S(seq)
	TEST(flags, BIT_LOOP)
	call gzabbr1s1
	call gzabbr1s2
	call gzabbr1s3
	ENDTEST(flags, BIT_LOOP)
* gzEND ABBR_S
	ENDTEST(flags, BIT_RESET)

* gzBEGIN ABBR_ANGLE
	seq(2) = seq(2) + 1
	INI_ANGLE(seq)
	TEST(flags, BIT_LOOP)
	call gzabbr1a
	ENDTEST(flags, BIT_LOOP)
* gzEND ABBR_ANGLE

* gzBEGIN RES_INI
	result(1) = 0
	result(2) = 0
* gzEND RES_INI

* gzBEGIN HEL_LOOPS
	LOOP_HEL(Hel1)
	TEST(helicities, BIT_HEL(1))

	LOOP_HEL(Hel2)
	TEST(helicities, BIT_HEL(2))

	LOOP_HEL(Hel3)
	TEST(helicities, BIT_HEL(3))

	LOOP_HEL(Hel4)
	TEST(helicities, BIT_HEL(4))

	EXEC(gzSquaredMEHel, result, flags)

	ENDTEST(helicities, BIT_HEL(4))
	ENDLOOP_HEL(Hel4)

	ENDTEST(helicities, BIT_HEL(3))
	ENDLOOP_HEL(Hel3)

	ENDTEST(helicities, BIT_HEL(2))
	ENDLOOP_HEL(Hel2)

	ENDTEST(helicities, BIT_HEL(1))
	ENDLOOP_HEL(Hel1)
* gzEND HEL_LOOPS

	SYNC(result)
	DEINI(seq)

#ifdef CHECK
	print *, 'S =', S
	print *, 'T =', T
	print *, 'U =', U
	print *, 'tree =', result(1)
	print *, 'loop =', result(2)
	stop
#endif

* gzEND SQUAREDME
	end

